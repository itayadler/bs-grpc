function emitGrpc() {
  return `
  /* AUTO-GENERATED BY bs-grpc --- EDIT AT YOUR OWN PERIL */
  exception BsGrpcDecoderError(string);
  exception ImpossibleError(string);
  let (<<) = (f, g, x) => f(g(x));
  /** an opaque type for error objects from grpc-node when the client invokes
   an RPC */
  type grpcClientRpcInvokeError;
  /* simply wraps grpcClientRpcInvokeError when an exception is needed */
  exception GrpcClientRpcInvokeError(grpcClientRpcInvokeError);

  /* "channel credentials" seem to be needed for creating a client */
  type channelCredentials;
  type callCredentials;
  type serverCredentials;

  /* protobufjs uses ByteBuffer abstraction over Node Buffer */
  type byteBuffer;
  [@bs.send] external bufferOfByteBuffer : byteBuffer => Node.buffer = "finish";

  /** return Some(x) for the first x of an array for which predictate f
   returns true, starting from element at index n, or None if no such element is
   found */
  let rec arrayFirst = (f, n, a) =>
    n < Array.length(a) ? f(a[n]) ? Some(a[n]) : arrayFirst(f, n + 1, a) : None;

  /* utility eunction; TODO is there a stdlib answer? */
  let optCall = (x, ~f) =>
    switch (x) {
    | None => ()
    | Some(x) => f(x)
    };

  /** Convenience function for simplifying server replies */
  let reply = (callback, x) =>
    callback(.
      Js.Nullable.null,
      x,
      Js.Nullable.undefined,
      Js.Nullable.undefined,
    );

  /** a type that cannot be instantiated */
  type uninstantiable;
  /** a type to only hold values like Js.Nullable.null and
   * Js.Nullable.undefined */
  type justNull = Js.Nullable.t(uninstantiable);
  type grpcLoadResult;

  [@bs.module "bs-grpc"] external grpcLoadProto : string => grpcLoadResult = "load";

  /* Represents a grpc.Server object */
  type server;
`
}

exports.emitGrpc = emitGrpc