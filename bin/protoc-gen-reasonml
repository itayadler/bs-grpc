#!/usr/bin/env node
/* Why is protobufjs giving me JS Number values to represent protobufs
 * enum values when grpc gives me JS String values?
 *
 * https://github.com/dcodeIO/protobuf.js/issues/97
 */
const pbjs = require('protobufjs')
const protobufs = require('../src/protobufs')
const Path = require('path')
const fs = require('fs')
const util = require('util')
const toposort = require('toposort')

const quote = s => {
  if ('string' !== typeof s)
    throw new Error("expecting string")
  return JSON.stringify(s)
}
const moduleDirName = moduleName => moduleName.split('.').slice(0, -1).join('.');
const FILE_MAGIC = '/* AUTO-GENERATED BY bs-grpc --- EDIT AT YOUR OWN PERIL */\n';
const preBoilerPlate = `
  exception BsGrpcDecoderError(string);
  exception ImpossibleError(string);
  let (<<) = (f, g, x) => f(g(x));
  /** an opaque type for error objects from grpc-node when the client invokes
   an RPC */
  type grpcClientRpcInvokeError;
  /* simply wraps grpcClientRpcInvokeError when an exception is needed */
  exception GrpcClientRpcInvokeError(grpcClientRpcInvokeError);

  /* "channel credentials" seem to be needed for creating a client */
  type channelCredentials;
  type callCredentials;
  type serverCredentials;

  /* protobufjs uses ByteBuffer abstraction over Node Buffer */
  type byteBuffer;
  [@bs.send] external bufferOfByteBuffer : byteBuffer => Node.buffer = "finish";

  /** return Some(x) for the first x of an array for which predictate f
   returns true, starting from element at index n, or None if no such element is
   found */
  let rec arrayFirst = (f, n, a) =>
    n < Array.length(a) ? f(a[n]) ? Some(a[n]) : arrayFirst(f, n + 1, a) : None;

  /* utility eunction; TODO is there a stdlib answer? */
  let optCall = (x, ~f) =>
    switch (x) {
    | None => ()
    | Some(x) => f(x)
    };

  /** Convenience function for simplifying server replies */
  let reply = (callback, x) =>
    callback(.
      Js.Nullable.null,
      x,
      Js.Nullable.undefined,
      Js.Nullable.undefined,
    );

  /** a type that cannot be instantiated */
  type uninstantiable;
  /** a type to only hold values like Js.Nullable.null and
   * Js.Nullable.undefined */
  type justNull = Js.Nullable.t(uninstantiable);
  type grpcLoadResult;

  [@bs.module "bs-grpc"] external grpcLoadProto : string => grpcLoadResult = "load";

  /* Represents a grpc.Server object */
  type server;
`
const boilerPlate = `
  /* A node.js bufffer TODO see if there is a more standard type somewhere
   * for this. We treat it as opaque, though, so it's probably okay.
   */
  type buffer;

  /* This type is part of the type of grpc.ServerCredentials.createSsl() */
  module ServerKeyAndCert {
    [@bs.deriving abstract]
    type t = {
      [@bs.as "private_key"] privateKey: buffer,
      [@bs.as "cert_chain"] certChain: buffer,
    };
  };
`

// TODO implement pascal case maker
const makeConstructorName = s => s;

let makeServerModule = (serviceModules) => {
  const servicesArgumentsList = serviceModules.map(serviceModule =>
    `~${lower1(lastDottedPart(serviceModule.moduleName))}=?,\n`
  ).join('')

  const bindServicesCode = serviceModules.map(serviceModule =>
    `${lower1(lastDottedPart(serviceModule.moduleName))}
    |. optCall(
      ~f=${serviceModule.moduleName}.addService(server)
    );
    `
  ).join('')

  return `
  module Server = {
    module Credentials = {
      /* These are the public static constructor functions for
       * grpc.ServerCredentials
       */
      module Ssl = {
        [@bs.module "@grpc/grpc-js"]
        [@bs.scope "ServerCredentials"]
        external make : (buffer, array(ServerKeyAndCert.t), bool) => serverCredentials =
          "createSsl";
        let make = (~rootCert: buffer, ~privateKey: buffer, ~certChain: buffer) =>
          make(
            rootCert,
            [|ServerKeyAndCert.t(~privateKey, ~certChain)|],
            true,
          );
      };
      module Insecure = {
        [@bs.module "@grpc/grpc-js"]
        [@bs.scope "ServerCredentials"]
        external make : unit => serverCredentials = "createInsecure";
      };
    };

    [@bs.module "@grpc/grpc-js"][@bs.new]
    external newServer : unit => server = "Server";

    [@bs.send]
    external serverBind: (server, string, serverCredentials, (string, int) => unit) => unit = "bindAsync";

    [@bs.send]
    external start : server => unit = "start";

    /** Convenience function to instantiate and configure a GRPC server */
    let make = (
      ~credentials,
      ${servicesArgumentsList}
      host,
    ) => {
      let server = newServer();
      serverBind(
        server,
        host,
        credentials,
        (_error, _port) => {
          ${bindServicesCode}
          start(server);
          ();
        },
      );
      server;
    };
  };
  `
}

const boilerPlate2 = `
  module Client = {
    module Metadata = {
      type t;
      [@bs.module "@grpc/grpc-js"] [@bs.new] external make : unit => t = "Metadata";
      [@bs.send] external set : (t, string, string) => unit = "";
      let set = (t, key, value) => {
        set(t, key, value);
        t
      };
      module Generator = {
        /** the type of the function you must call to furnish an RPC invocation with
         either its metadata or a metadata generation error. see \`makeGenerator\`
        for details */
        type complete = (Js.Nullable.t(exn), t) => unit;
        /** consumers of bs-grpc who want to use metadata must implement a function
         of this type. see \`makeGenerator\` for more details */
        type generatorImplementation = (unit, complete) => unit;
        /** to populate a grpc request with metadata, grpc-node requires you to
         supply a metadata generator function, which receives as its first argument
         the call object reflecting the request payload (not available in this
         binding) while the second argument is a function your metadata generator
         function must invoke with either an exception or the resulting metadata */
        [@bs.module "@grpc/grpc-js"]
        [@bs.scope "credentials"]
        external make : generatorImplementation => callCredentials =
          "createFromMetadataGenerator";
      };
    };

    module Credentials = {
      [@bs.module "@grpc/grpc-js"]
      [@bs.scope "credentials"]
      external createInsecure : unit => channelCredentials = "";

      [@bs.module "@grpc/grpc-js"]
      [@bs.scope "credentials"]
      external createSsl : (buffer, buffer, buffer) => channelCredentials = "";

      [@bs.module "@grpc/grpc-js"]
      [@bs.scope "credentials"]
      external combine
        : (channelCredentials, callCredentials)
        => channelCredentials
        = "combineChannelCredentials";

      [@bs.module "@grpc/grpc-js"]
      [@bs.scope "credentials"]
      external combine3
        : (channelCredentials, callCredentials, callCredentials)
        => channelCredentials
        = "combineChannelCredentials";
    }
  };

  /* use this to load a nodejs Buffer object containing a base64-encoded
   * PEM format key/certificate
   */
  [@bs.val] [@bs.module "fs"]
  external loadCert : string => buffer = "readFileSync";
`

const dottedModuleName = moduleName =>
  moduleName.split('.').map((s, i) =>
    s[0].toUpperCase() + s.substr(1)
  ).join('.')
const lastDottedPart = moduleName => {
  const a = moduleName.split('.')
  return a[a.length - 1]
}
const mapMessageType = messageType => messageType[1].toUpperCase() + messageType.substr(2) + '.t';
const mapTypeNameToModuleName = enumTypeName => enumTypeName[1].toUpperCase() + enumTypeName.substr(2)
const mapEnumType = enumTypeName => mapTypeNameToModuleName(enumTypeName) + '.t';
const joinModuleName = (...args) => args.map(s => s[0] == '.' ? s.substr(1) : s).join('.')
const resolveRelative = (moduleName, scopeName) => {
  const scopeParts = scopeName.split('.')
  const moduleParts = moduleName.split('.')
  const max = Math.max(scopeParts.length, moduleParts.length)
  for (let i = 0; i < max; i++)
    if (scopeParts[i] !== moduleParts[i])
      return moduleParts.slice(i).join('.')
  throw new Error("how do i name myself?")
}
const lower1 = s => s[0].toLowerCase() + s.substr(1)
const upper1 = s => s[0].toUpperCase() + s.substr(1)

const mapJustType = (fieldProto, scopeName) => {
  switch (fieldProto.type) {
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_GROUP:
    default:
      return 'unknown_type /*' + type + '*/';
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_ENUM:
      return upper1(resolveRelative(mapEnumType(fieldProto.typeName), scopeName))
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_MESSAGE:
      return upper1(resolveRelative(mapMessageType(fieldProto.typeName), scopeName))
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_BOOL:
      return 'bool'
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_BYTES:
      return 'UNHANDLED_TYPE_BYTES'
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_STRING:
      return 'string'
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_DOUBLE:
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_FLOAT:
      return 'float'
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_FIXED32:
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_INT32:
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_SFIXED32:
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_SINT32:
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_UINT32:
      return 'int'
    /* TODO in the future we'll want more flexibility in how we represent 64-bit values */
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_FIXED64:
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_INT64:
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_SFIXED64:
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_SINT64:
    case protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_UINT64:
      return 'string'
  }
}
const mapType = (field, scopeName) => {
  const justType = mapJustType(field, scopeName)
  switch (field.label) {
    default:
    case protobufs.google.protobuf.FieldDescriptorProto.Label.LABEL_OPTIONAL:
      return ['[@bs.optional]', justType]
    case protobufs.google.protobuf.FieldDescriptorProto.Label.LABEL_REPEATED:
      return ['[@bs.optional]', `array(${justType})`]
    case protobufs.google.protobuf.FieldDescriptorProto.Label.LABEL_REQUIRED:
      return ['/* required */', justType]
  }
}
/** similar to mapType, but emits 'int' for ENUMs */
const mapTypeForMessageField = (field, scopeName) => {
  if (field.type == protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_ENUM)
    field = { ...field, type: protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_INT32 }
  return mapType(field, scopeName)
}
function isEnumField(field) { return field.type == protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_ENUM }
function someEnumFields(fields) { return fields.some(isEnumField) }
/* make function names for converting between protobufjs' representation of values of enums and bs-grpc's representation */
function makeFunNameConvEnumOfInt(enumModuleRef) { return `${upper1(enumModuleRef)}.${lower1(enumModuleRef)}OfInt` }
function makeFunNameConvIntOfEnum(enumModuleRef) { return `${upper1(enumModuleRef)}.intOf${upper1(enumModuleRef)}` }

require('read-all-stream')(process.stdin, { encoding: null }).then(buf => {
  let protoHandleFields = ''
  const reader = pbjs.Reader.create(buf)
  const req = protobufs.google.protobuf.compiler.CodeGeneratorRequest.decode(buf)
  //console.error(util.inspect(req, {depth:999}))

  // XXX deleting noise garbage i don't want to see
  req.protoFile.forEach(protoFile => delete protoFile.sourceCodeInfo)

  /* In order to support custom options in our .proto file, we need to allocate
   * message fields in the protobuf messages that protoc uses to represent our
   * .proto files to our plugin. To do this we need to use the "extend"
   * capability of protobufs. To my intuition, we would apply this step when
   * generating our protoc protobuf compiler, so that the compiler knows about
   * our custom options and how to represent them to our plugin. I
   * haven't been able to figure out a way to do this. Instead, however, we can
   * apparently do the extend at protoc's runtime. Until a better solution is
   * discovered, I am blacklisting the following root packages (__no_emit being
   * my own invention) so that we do not emit code for them.
   *
   * It seems that __no_emit was not actually useful as in order to access any
   * extensions defined by a .proto package with such a name, you'd have to
   * write __no_emit everywhere, and I find that too unattractive. I'm leaving
   * it in here in case someone finds it useful, though.
   *
   * I'm adding 'tin' to this list so that users can import tin.proto and we
   * don't emit code for it, however I've decided that this simply isn't the
   * best way to do this. In the case of tin.proto, for now at least, it would
   * work to simply check whether or not the file defines any messages or
   * services, and omit emission in such a case.
   *
   * TODO investigate using CodeGeneratorRequest.file_to_generate or
   * CodeGeneratorRequest.parameter
   */
  const packagePrefixesToIgnore = ['__no_emit', 'google.', 'tin.']
  req.protoFile = req.protoFile.filter(protoFile =>
    !packagePrefixesToIgnore.some(prefix =>
      protoFile.package.substr(0, prefix.length) == prefix
    )
  )

  const rootModule = { moduleName: '*root*', modules: {} }

  function handleMessageType(parentModule, messageType) {
    /* Create module for this message type */
    const moduleName = dottedModuleName(joinModuleName(parentModule.moduleName, messageType.name))
    const module = {
      modules: {},
      moduleName
    }
    parentModule.modules[lastDottedPart(moduleName)] = module
    const message = module.t = {
      fields: messageType.field.map(field => ({
        name: field.name,
        type: field.type,
        typeName: field.typeName,
        label: field.label,
        oneofIndex: field.hasOwnProperty('oneofIndex') ? field.oneofIndex : -1,
      })),
      oneofs: messageType.oneofDecl.map(oneof => ({
        name: oneof.name,
        fields: []
      })),
    }
    messageType.field.forEach((field, iField) => {
      if (field.hasOwnProperty('oneofIndex')) {
        const oneofIndex = field.oneofIndex
        message.oneofs[field.oneofIndex].fields.push(
          message.fields[iField]
        )
      }
    })
    messageType.nestedType.forEach(nestedType => {
      handleMessageType(module, nestedType)
    })
    messageType.enumType.forEach(enumType => {
      handleEnumType(module, enumType)
    })
  }

  function enumName(name) {
    return name.split('_').map(part => part[0].toUpperCase() + part.substr(1).toLowerCase()).join('')
  }

  function mapEnumValues(values) {
    return values.map(enumValue => ({
      name: enumName(enumValue.name),
      number: enumValue.number
    }))
  }

  function handleEnumType(parentModule, enumType) {
    const moduleName = dottedModuleName(joinModuleName(parentModule.moduleName, enumType.name))
    const module = {
      modules: {},
      moduleName,
      t: { enumValues: mapEnumValues(enumType.value) }
    }
    parentModule.modules[lastDottedPart(moduleName)] = module
  }

  /* For each .proto file... */
  req.protoFile.forEach(protoFile => {
    if (!protoFile.package) {
      console.error('your .proto file must contain a package name')
      process.exit(1)
    }
    /* Create module for this proto file */
    const protoFileModuleName = dottedModuleName(protoFile.package)
    const protoFileModule = {
      modules: {},
      moduleName: protoFileModuleName,
      packageName: protoFile.package,
      fileName: protoFile.name,
    }
    rootModule.modules[lastDottedPart(protoFileModuleName)] = protoFileModule
    /* For each message type defined... */
    protoFile.messageType.forEach(messageType => {
      handleMessageType(protoFileModule, messageType)
    })
    protoFile.enumType.forEach(enumType => {
      handleEnumType(protoFileModule, enumType)
    })
    protoFile.service.forEach(service => {
      const moduleName = joinModuleName(protoFileModuleName, service.name)
      const serviceModule = {
        modules: [],
        moduleName,
        /* service modules need this to find their loaded protobuf specs */
        serviceName: service.name,
        rpcs: service.method.map(method => {
          /* TODO support streaming */
          const name = method.name
          const inputType = mapMessageType(method.inputType)
          const outputType = mapMessageType(method.outputType)
          return {
            name,
            inputType,
            outputType
          }
        })
      }
      protoFileModule.modules[lastDottedPart(moduleName)] = serviceModule
    })
  })

  function identifyModulesArray() {
    const foundModules = []
    recurse(rootModule)
    function recurse(module) {
      foundModules.push(module)
      for (let moduleName in module.modules)
        recurse(module.modules[moduleName])
    }
    return foundModules;
  }
  function identifyServices() {
    const foundServices = {}
    recurse(rootModule)
    function recurse(module) {
      if ('rpcs' in module)
        foundServices[module.moduleName] = {
          fileName: module.fileName,
          module,
        }
      for (let moduleName in module.modules)
        recurse(module.modules[moduleName])
    }
    return foundServices
  }
  const dependencies = []
  identifyModulesArray().forEach(module => {
    if (module.moduleName !== '*root*') {
      dependencies.push(['*root*', module.moduleName])
      if (module.moduleName.indexOf('.') >= 0)
        dependencies.push([moduleDirName(module.moduleName), module.moduleName])
    }
    if ('t' in module) {
      /* we could emit our 't' without this, but this is necessary for
       * detecting cyclic dependencies */
      dependencies.push([module.moduleName, module.moduleName + '.t'])
      if ('fields' in module.t) {
        module.t.fields.forEach(field => {
          if (field.type == protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_ENUM
            || field.type == protobufs.google.protobuf.FieldDescriptorProto.Type.TYPE_MESSAGE) {
            dependencies.push([mapMessageType(field.typeName), module.moduleName])
          }
        })
      }
    }
    if ('rpcs' in module) {
      module.rpcs.forEach(rpc => {
        dependencies.push([rpc.inputType, module.moduleName])
        dependencies.push([rpc.outputType, module.moduleName])
      })
    }
  }, [])
  const dependencySortedModuleNames = toposort(dependencies).slice(1)

  const emitModule = module => {
    let code = ''
    /* diagnostic output */
    code += `/* fileName = "${module.fileName}" */\n`
    code += `/* moduleName = "${module.moduleName}" */\n`
    /* Invoke grpc-node's load() method to generate and load javascript
     * bindings to our .proto
     */
    if ('fileName' in module) {
      /* TODO will path be correct at runtime?
       * TODO escape path
       */
      code += `
        type grpcProtoHandle;
        [@bs.get] external getProtoHandle : grpcLoadResult => grpcProtoHandle = "${module.packageName}";
        let myProtoHandle = grpcLoadProto(${JSON.stringify(module.fileName)}) |> getProtoHandle;
      `
    }
    /* sort sub-modules by order of dependency */
    const subModuleOrder = Object.keys(module.modules).map(shortModuleName => {
      const moduleName = module.modules[shortModuleName].moduleName
      return {
        shortModuleName,
        position: dependencySortedModuleNames.indexOf(moduleName)
      }
    })
    subModuleOrder.sort((a, b) => a.position - b.position)
    /* emit code for each sub-module in order */
    subModuleOrder.forEach(subModulePosition => {
      const shortModuleName = subModulePosition.shortModuleName
      code += `module ${shortModuleName} {\n`
      code += emitModule(module.modules[shortModuleName])
      code += `};\n`
    })
    /* emit code for any type contained in our module */
    if ('t' in module) {
      if ('fields' in module.t) {
        const hasEnumField = someEnumFields(module.t.fields)
        code += `/* Message module */
          [@bs.deriving abstract]
          type t =
        `
        if (module.t.fields.length) {
          code += "{\n"
          module.t.fields.forEach(field => {
            const [fieldQualifier, fieldType] = mapTypeForMessageField(field, module.moduleName)
            code += `${fieldQualifier} ${field.name} : ${fieldType},\n`
          })
          module.t.oneofs.forEach(oneof => {
            code += `/* oneof */ ${oneof.name}: string,\n`;
          })
          code += "}";
        } else {
          code += "{ /* this type needs at least one field */ [@bs.optional] dontSetMe : string }"
        }
        code += ";\n";
        /* to support enums, we need to provide our own accessors of enum
         * fields that convert between protobufjs' representation of enums
         * (javascript Number values) and our own variant type */
        if (hasEnumField) {
          /* first shadow the deriving abstract constructor function */
          code += `/** message constructor (shadows the deriving abstract constructor) */
            let t = (
          `
          module.t.fields.forEach(field => {
            if (field.oneofIndex < 0) {
              code += `~${field.name}=?,\n`
            }
          })
          module.t.oneofs.forEach(oneof => {
            code += `~${oneof.name},\n`
          })
          code += '()) => t(\n'
          module.t.fields.forEach(field => {
            if (isEnumField(field)) {
              const enumModuleRef = resolveRelative(mapTypeNameToModuleName(field.typeName), module.moduleName)
              const conv = makeFunNameConvIntOfEnum(enumModuleRef)
              code += `~${lower1(field.name)} =? (`
              code += `@@ ${conv}) @@ ${lower1(field.name)},\n`
            } else {
              code += `~${lower1(field.name)}?,\n`
            }
          })
          code += `());\n`
          module.t.fields.forEach(field => {
            if (isEnumField(field)) {
              const enumModuleRef = resolveRelative(mapTypeNameToModuleName(field.typeName), module.moduleName)
              const conv = makeFunNameConvEnumOfInt(enumModuleRef)
              code += `/* enum converting getter */
                let ${field.name}Get =
              `
              code += `@@ ${conv} << ${field.name}Get;
              `
            }
          })
        }
        /* to support protobufs oneof fields, we create a variant type for
         * each oneof.
         */
        module.t.oneofs.forEach(oneof => {
          /* variant type for oneof */
          code += `type ${oneof.name} =\n`
          oneof.fields.forEach(field => {
            const justType = mapJustType(field, module.moduleName)
            const constructorName = makeConstructorName(justType)
            code += `| ${upper1(field.name)}(${constructorName})\n`
          })
          code += ';\n'
        })
        /* Emit a new constructor function overriding the one emitted by
         * [@bs.deriving abstract] which accepts our oneof variants
         *
         * TODO hide the abstract constructor function "t"
         */
        code += `/* safe message constructor (may replace t()) */\nlet make = (\n`
        module.t.fields.forEach(field => {
          if (field.oneofIndex < 0) {
            code += `~${field.name}=?,\n`
          }
        })
        module.t.oneofs.forEach(oneof => {
          code += `~${oneof.name},\n`
        })
        code += '()) => t(\n'
        module.t.fields.forEach(field => {
          /* Note the question mark here indicates that we will be passing
           * an option-boxed values explicitly
           */
          code += `~${field.name} =?`
          if (field.oneofIndex >= 0) {
            const oneof = module.t.oneofs[field.oneofIndex]
            code += `(${oneof.name} |> /* fun1 */ fun\n`
            oneof.fields.forEach(field2 => {
              const varName = field === field2 ? 'x' : '_';
              const valCode = field === field2 ? `Some(x)` : 'None';
              code += `| ${upper1(field2.name)}(${varName}) => ${valCode}\n`
            })
            code += `),`
          } else {
            code += `${field.name},`
          }
          code += `\n`
        })
        module.t.oneofs.forEach(oneof => {
          code += `~${oneof.name} = (${oneof.name} |> (/* fun2 */ fun\n`
          oneof.fields.forEach(field1 => {
            code += `| ${upper1(field1.name)}(_) => ${JSON.stringify(field1.name)}\n`
          })
          code += `))\n,\n`
        })
        code += `());\n`
        /* We'll also override the oneofs' accessor functions (which would
         * only give us a string indicating which of a oneof's fields
         * contains a value) to provide a value of the variant type we
         * created to represent each oneof field
         */
        module.t.oneofs.forEach(oneof => {
          code += `/* Oneof variant getter */
          let ${oneof.name} = x => x |> ${oneof.name}Get |> (/* fun3 */ fun\n`
          oneof.fields.forEach(field => {
            code += `| ${JSON.stringify(field.name)} => ${upper1(field.name)}(
              x |> ${field.name}Get |> ( /* fun4 */ fun
              | Some (x) => x
              | None => raise(BsGrpcDecoderError("expected Some ${field.name}"))
              )
            )\n`
          })
          code += `
          | _ => raise(ImpossibleError("decoding oneof field switch invalid"))
          );
          `
        })
        code += `
           type codec;

          [@bs.send] external encode : (codec, t, justNull, justNull) => byteBuffer = "";
          [@bs.send] external decode : (codec, Node.buffer, justNull, justNull) => t = "";

          [@bs.get] external codec : grpcProtoHandle => codec = ${quote(lastDottedPart(module.moduleName))};

          let codec = myProtoHandle |. codec;

          let encode = x =>
            encode(codec, x, Js.Nullable.undefined, Js.Nullable.undefined)
            |. bufferOfByteBuffer;
          let decode = x =>
            decode(codec, x, Js.Nullable.undefined, Js.Nullable.undefined);
        `
      } else if ('enumValues' in module.t) {
        const shortName = lastDottedPart(module.moduleName)
        code += `
          /* enum type */
          type t =
        `
        module.t.enumValues.forEach(enumValue => {
          code += `| ${enumValue.name}\n`
        })
        code += `;
          /** convert a grpc enum ordinal to its ${shortName}.t counterpart; internal */
          let ${lower1(shortName)}OfInt = fun
        `
        module.t.enumValues.forEach(enumValue => {
          code += `| ${enumValue.number} => ${enumValue.name}\n`
        })
        code += `
          | x => raise(BsGrpcDecoderError({j|bs-grpc encountered invalid ${shortName} enum value $x|j}));
          /** convert a ${shortName}.t to its the grpc enum ordinal counterpart; internal */
          let intOf${upper1(shortName)} = fun
        `
        module.t.enumValues.forEach(enumValue => {
          code += `| ${enumValue.name} => ${enumValue.number}\n`
        })
      }
    }
    /* emit code for any RPCs */
    if ('rpcs' in module) {
      module.rpcs.forEach(rpc => {
        const inputType = resolveRelative(rpc.inputType, module.moduleName)
        const outputType = resolveRelative(rpc.outputType, module.moduleName)
        code += `
          module ${upper1(rpc.name)}Rpc {
            /* Rpc module */
            /** the input/request type of the ${rpc.name} RPC */
            type inputType = ${inputType};
            /** the output/reply type of the ${rpc.name} RPC */
            type outputType = ${outputType};
            /** the type of the object from which rpc implementations may
             * obtain request payload and metadata. an object of this type is
             * passed to your rpc implementation. */
            [@bs.deriving abstract]
            type call = { request: inputType };
            /** server implementation function type. request payload and
             * metadata can be obtained via the \`call\` argument furnished to
             * your rpc implementation. the second argument allows you to
             * furnish a reply, although three of its four arguments should be
             * unused. */
            type t = (
              call,
              (.
                justNull,
                outputType,
                justNull,
                justNull
              ) => unit
            ) => unit;
            let getMeta : call => Js.Dict.t(Js.Json.t) = [%bs.raw {|
              call => call.metadata.getMap()
            |}];
          };
        `
      })
      code += `
        /** objects of this type are actually grpc service client constructor
         * functions, however, they have a property, "service," whose value is
         * used to add services to a server object, too. */
        type grpcServiceObject;
        [@bs.get]
        external myServiceClient
          : grpcProtoHandle => grpcServiceObject
          = ${JSON.stringify(module.serviceName)};
        let myServiceClient = myProtoHandle |> myServiceClient;
        module Client = {
          /** a client object for the ${module.serviceName} service */
          type t;
          /** the type of the error argument in the callback you supply when
           you invoke an rpc */
          type maybeError = Js.Nullable.t(grpcClientRpcInvokeError);
          /* client construction */
          let makeClient : (grpcServiceObject, string, channelCredentials) => t = [%bs.raw "(x,y,z) => new x(y,z)"];
          /** construct a client for the ${rootModule.packageName}.${module.moduleName} grpc service. arguments:
           serverAddress: string of address and port of server (e.g. "127.0.0.1:12345")
           chanCreds: your channel credentials */
          let makeClient = (serverAddress, chanCreds) => makeClient(myServiceClient, serverAddress, chanCreds);
      `
      module.rpcs.forEach(rpc => {
        const rpcModuleRef = upper1(rpc.name) + 'Rpc'
        const myModuleName = rpcModuleRef
        const inputType = rpcModuleRef + '.inputType'
        const outputType = rpcModuleRef + '.outputType'
        code += `
          module ${myModuleName} = {
            /** the type of the callback you must supply when you invoke an rpc */
            type callback = (maybeError, ${outputType}) => unit;
            /** invoke an rpc using callback style. arguments:
             t: the client over which to send the rpc request
             ${inputType}: the request payload message
             callback: a function which will be invoked when a reply from the
               server is available, or when an error occurs */
            [@bs.send]
            external invoke : (t, ${inputType}, callback) => unit = ${quote(lower1(rpc.name))};
            /** invoke an rpc using promises */
            let invokePromise = (client, input) => Js.Promise.make((~resolve, ~reject) => {
              invoke(client, input, (err, res) => {
                switch (err |. Js.Nullable.toOption) {
                | Some(err) => reject(. GrpcClientRpcInvokeError(err))
                | None => resolve(. res)
                }
              });
            });
          }
        `
      })
      code += `
        };
        type grpcServiceServer;
        [@bs.get]
        external getServerServiceHandle : grpcServiceObject => grpcServiceServer =
          "service";
        let myServerServiceHandle = myServiceClient |> getServerServiceHandle;
      `
      /* the deriving abstract record type is chosen because it can be fed
       * directly to grpc-node's grpc.Server#addService method
       */
      code += '/* Service implementation type */\n[@bs.deriving abstract]\ntype t = {\n'
      module.rpcs.forEach(rpc => {
        code += `${lower1(rpc.name)}: ${upper1(rpc.name)}Rpc.t,\n`;
      })
      code += `};
        [@bs.send] external addService : (server, grpcServiceServer, t) => unit = "";
        let addService = (server, t) =>
          addService(server, myServerServiceHandle, t);
        /** creates an implementation of the ${module.serviceName}. The RPC
         * implementations you pass to this function will only be invoked after
         * any sanitization/normalization code has processed the
         * message without error. */
        let make = (
      `
      module.rpcs.forEach(rpc => {
        code += `~${lower1(rpc.name)},\n`;
        code += `~_${lower1(rpc.name)}ErrorHandler,\n`;
      })
      code += `\n) => t(\n`;
      module.rpcs.forEach(rpc => {
        code += `
                ~${lower1(rpc.name)}=
          (call, callback) => {
            let request = call |. ${upper1(resolveRelative(rpc.name, module.moduleName))}Rpc.requestGet;
            ${lower1(rpc.name)}(call, request, callback);
          },
        `
      })
      code += `)\n`;
    }
    if (module === rootModule) {
      const services = identifyServices()
      const serviceModules = []
      for (let k in services)
        serviceModules.push(services[k].module)
      const serverModuleCode = makeServerModule(serviceModules)

      code += serverModuleCode
    }
    return code
  }

  const moduleMeat = emitModule(rootModule)

  const emission = FILE_MAGIC
    + preBoilerPlate
    + boilerPlate
    + moduleMeat
    + boilerPlate2

  if (process.stdout.isTTY) {
    console.log('stdout is a TTY; printing human-readable data')
    console.log('output module tree:', util.inspect(rootModule, { depth: 99 }))
    console.log('output source code:')
    console.log(emission)
  } else {
    process.stdout.write(
      protobufs.google.protobuf.compiler.CodeGeneratorResponse.encode({
        file: [{
          name: 'Grpc.re',
          content: emission
        }]
      }).finish()
    )
  }
}).catch(err => {
  console.error(__filename, "error", err)
})
